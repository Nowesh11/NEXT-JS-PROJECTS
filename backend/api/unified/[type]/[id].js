import dbConnect from '../../../../lib/mongodb';
import UnifiedProject from '../../../../models/UnifiedProject';
import { ObjectId } from 'mongodb';

export default async function handler(req, res) {
  const { method, query } = req;
  const { type, id } = query;

  // Validate type parameter
  const validTypes = ['projects', 'activities', 'initiatives'];
  if (!validTypes.includes(type)) {
    return res.status(400).json({ 
      success: false, 
      error: 'Invalid type. Must be one of: projects, activities, initiatives' 
    });
  }

  // Validate ID parameter
  if (!id || !ObjectId.isValid(id)) {
    return res.status(400).json({ 
      success: false, 
      error: 'Valid ID is required' 
    });
  }

  // Convert plural to singular for database query
  const dbType = type.slice(0, -1); // Remove 's' from end

  await dbConnect();

  switch (method) {
    case 'GET':
      try {
        const item = await UnifiedProject.findOne({ 
          _id: id, 
          type: dbType 
        }).lean();

        if (!item) {
          return res.status(404).json({ 
            success: false, 
            error: `${type.slice(0, -1)} not found` 
          });
        }

        // Add computed fields
        const itemWithComputed = {
          ...item,
          primaryImage: item.primary_image || `/assets/default-${item.type}.jpg`,
          imagesCount: item.images ? item.images.length : 0,
          isActive: item.status === 'active',
          isCompleted: item.status === 'completed' || item.progress === 100,
          progressStatus: getProgressStatus(item.progress)
        };

        // Increment view count if not admin request
        if (!req.headers.authorization) {
          await UnifiedProject.findByIdAndUpdate(id, {
            $inc: { views_count: 1 }
          });
        }

        res.status(200).json({
          success: true,
          data: itemWithComputed
        });
      } catch (error) {
        console.error(`Error fetching ${type.slice(0, -1)}:`, error);
        res.status(500).json({ 
          success: false, 
          error: `Failed to fetch ${type.slice(0, -1)}` 
        });
      }
      break;

    case 'PUT':
      try {
        const updateData = {
          ...req.body,
          type: dbType,
          updatedAt: new Date()
        };

        // Remove fields that shouldn't be updated directly
        delete updateData._id;
        delete updateData.createdAt;
        delete updateData.views_count;
        delete updateData.slug; // Slug will be regenerated by pre-save middleware

        // Validate bilingual fields if provided
        const bilingualFields = ['title', 'description', 'director', 'goals'];
        for (const field of bilingualFields) {
          if (updateData[field]) {
            if (!updateData[field].en || !updateData[field].ta) {
              return res.status(400).json({
                success: false,
                error: `Both English and Tamil versions of ${field} are required`
              });
            }
          }
        }

        const updatedItem = await UnifiedProject.findOneAndUpdate(
          { _id: id, type: dbType },
          updateData,
          { 
            new: true, 
            runValidators: true 
          }
        );

        if (!updatedItem) {
          return res.status(404).json({ 
            success: false, 
            error: `${type.slice(0, -1)} not found` 
          });
        }

        res.status(200).json({
          success: true,
          data: updatedItem,
          message: `${type.slice(0, -1)} updated successfully`
        });
      } catch (error) {
        console.error(`Error updating ${type.slice(0, -1)}:`, error);
        
        if (error.name === 'ValidationError') {
          const errors = Object.values(error.errors).map(err => err.message);
          return res.status(400).json({
            success: false,
            error: 'Validation failed',
            details: errors
          });
        }

        if (error.code === 11000) {
          return res.status(400).json({
            success: false,
            error: 'A record with this slug already exists'
          });
        }

        res.status(500).json({ 
          success: false, 
          error: `Failed to update ${type.slice(0, -1)}` 
        });
      }
      break;

    case 'DELETE':
      try {
        const deletedItem = await UnifiedProject.findOneAndDelete({ 
          _id: id, 
          type: dbType 
        });

        if (!deletedItem) {
          return res.status(404).json({ 
            success: false, 
            error: `${type.slice(0, -1)} not found` 
          });
        }

        // TODO: Delete associated files from storage
        // if (deletedItem.primary_image) {
        //   await deleteFile(deletedItem.primary_image);
        // }
        // if (deletedItem.images && deletedItem.images.length > 0) {
        //   await Promise.all(deletedItem.images.map(deleteFile));
        // }

        res.status(200).json({
          success: true,
          message: `${type.slice(0, -1)} deleted successfully`,
          data: { id: deletedItem._id }
        });
      } catch (error) {
        console.error(`Error deleting ${type.slice(0, -1)}:`, error);
        res.status(500).json({ 
          success: false, 
          error: `Failed to delete ${type.slice(0, -1)}` 
        });
      }
      break;

    case 'PATCH':
      try {
        const { action, ...patchData } = req.body;

        let updateOperation = {};

        switch (action) {
          case 'toggle-status':
            const currentItem = await UnifiedProject.findOne({ _id: id, type: dbType });
            if (!currentItem) {
              return res.status(404).json({ 
                success: false, 
                error: `${type.slice(0, -1)} not found` 
              });
            }
            updateOperation = {
              status: currentItem.status === 'active' ? 'inactive' : 'active',
              updatedAt: new Date()
            };
            break;

          case 'toggle-featured':
            updateOperation = {
              $bit: { featured: { xor: 1 } },
              updatedAt: new Date()
            };
            break;

          case 'update-progress':
            if (typeof patchData.progress !== 'number' || patchData.progress < 0 || patchData.progress > 100) {
              return res.status(400).json({
                success: false,
                error: 'Progress must be a number between 0 and 100'
              });
            }
            updateOperation = {
              progress: patchData.progress,
              status: patchData.progress === 100 ? 'completed' : 'active',
              updatedAt: new Date()
            };
            break;

          case 'update-priority':
            if (!['low', 'medium', 'high', 'urgent'].includes(patchData.priority)) {
              return res.status(400).json({
                success: false,
                error: 'Priority must be one of: low, medium, high, urgent'
              });
            }
            updateOperation = {
              priority: patchData.priority,
              updatedAt: new Date()
            };
            break;

          default:
            return res.status(400).json({
              success: false,
              error: 'Invalid action. Supported actions: toggle-status, toggle-featured, update-progress, update-priority'
            });
        }

        const updatedItem = await UnifiedProject.findOneAndUpdate(
          { _id: id, type: dbType },
          updateOperation,
          { new: true }
        );

        if (!updatedItem) {
          return res.status(404).json({ 
            success: false, 
            error: `${type.slice(0, -1)} not found` 
          });
        }

        res.status(200).json({
          success: true,
          data: updatedItem,
          message: `${type.slice(0, -1)} ${action} completed successfully`
        });
      } catch (error) {
        console.error(`Error patching ${type.slice(0, -1)}:`, error);
        res.status(500).json({ 
          success: false, 
          error: `Failed to update ${type.slice(0, -1)}` 
        });
      }
      break;

    default:
      res.setHeader('Allow', ['GET', 'PUT', 'DELETE', 'PATCH']);
      res.status(405).json({ 
        success: false, 
        error: `Method ${method} not allowed` 
      });
      break;
  }
}

// Helper function to determine progress status
function getProgressStatus(progress) {
  if (progress === 0) return 'not-started';
  if (progress < 25) return 'just-started';
  if (progress < 50) return 'in-progress';
  if (progress < 75) return 'halfway';
  if (progress < 100) return 'almost-done';
  return 'completed';
}